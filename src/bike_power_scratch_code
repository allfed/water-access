# bike power calculation
import math
import numpy as np
import matplotlib.pyplot as plt

# a few plausible factors from http://www.cyclingpowerlab.com/CyclingAerodynamics.aspx
dragCoeff = 0.9
frontalArea = 0.51

rho = 1.225
eta = 0.90 # - drive train loss = efficiency
rollingCoeff = 0.003 # 
mass = 79 #kg
grade = 0/360*2*np.pi
g = 9.81

# functions to compute the various forces:
def fDrag(velocity):
    return 0.5*dragCoeff*frontalArea*rho*velocity*velocity

def fRolling(grade, mass, velocity):
    if velocity > 0.01:
        return g * math.cos(math.atan(grade)) * mass * rollingCoeff
    else:
        return 0.0

def fGravity(grade, mass):
    return g*math.sin(math.atan(grade))*mass

# the actual program:
v=0.0  # initial velocity
power = 75 # constant power in W
dt = 1    # time step
va=[0]      # store the results in a list which will grow in each iteration
ta=[0]
t_mins_between_stops = 5
t_secs = t_mins_between_stops*60


# loop over time:
for t in np.arange(0,t_secs,dt):
    totalForce = fDrag(v) + fRolling(grade, mass, v) + fGravity(grade, mass)
    powerNeeded = totalForce * v / eta
    netPower = power - powerNeeded
    # kinetic energy increases by net energy available for dt
    print("t = %.2f; v=%.2f; drag = %.2f N; F roll = %.2f N; F gravity = %.2f N"%(t, v, fDrag(v), fRolling(grade, mass, v), fGravity(grade, mass)))
    v = math.sqrt(v*v + 2 * netPower * dt * eta / mass)
    va.append(v)
    ta.append(t+dt)


print(f'Mean {np.mean(va)}')
print(f'Max {v}')
print(f'ratio {(v - np.mean(va))/v}' )

plt.figure()
plt.plot(ta, va)
plt.xlabel('time (s)')
plt.ylabel('velocity (m/s)')
plt.show()